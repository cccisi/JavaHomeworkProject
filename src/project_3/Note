说明各程序运行情况，并简要分析原因。
ThreadTest1
【结果】： 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 / 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 / 其他
【分析】： ThreadTest1分别创建了两个对象，且ThreadTest1的方法没有synchronized关键字，因此两个线程的执行没有影响，它们可以分别打印出数字，每次执行结果有一定随机性，不完全确定

ThreadTest2
【结果】：  0 1 0 2 1 3 2 4 3 5 6 7 4 8 5 9 6 7 8 9 / 0 1 2 0 3 1 4 2 5 3 6 4 7 5 8 6 9 7 8 9
【分析】：这时创建了两个ThreadTest2的对象r1和r2，线程t1执行的是1对象中的ThreadTest2代码run，而线程t2执行的是2对象中的ThreadTest2代码run；
          synchronized锁定的是对象，这时会有两把锁分别锁定1对象和rr2对象，而这两把锁是互不干扰的，不形成互斥，所以两个线程可以同时执行

ThreadTest3
【结果】： 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
【分析】：当两个并发线程(t1和t2)访问同一个对象(ThreadTest3)中的run方法时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块；
          t1和t2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象

ThreadTest4
【结果】： 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
【分析】：ThreadTest3修饰的是一个方法，ThreadTest4修饰的是一个代码块，但二者是等价的，都是锁定了整个方法时的内容


